// src/pages/VideoPage.tsx - COMPLETE FIXED VERSION
import React, { useEffect, useRef, useState } from "react";
import {
  Container,
  Row,
  Col,
  Card,
  Nav,
  Tab,
  Button,
  Spinner,
  Modal,
  Form,
  Alert,
  Table,
  Badge,
} from "react-bootstrap";

import {
  FaMicrophone,
  FaMicrophoneSlash,
  FaVideo,
  FaVideoSlash,
  FaPhoneSlash,
  FaCopy,
  FaCheck,
} from "react-icons/fa";

import { io, Socket } from "socket.io-client";
import { useSession } from "@supabase/auth-helpers-react";
import { supabase } from "../lib/supabaseClient";

const SERVER_URL = import.meta.env.VITE_SOCKET_URL || "${import.meta.env.VITE_API_URL || import.meta.env.VITE_SOCKET_URL || "http://localhost:4000"}";

interface Participant {
  id: string;
  user_id: string;
  user_name: string;
  role: string;
  isSelf?: boolean;
}

interface ChatMessage {
  id?: string;
  user_id: string;
  user_name: string;
  message: string;
  created_at: string;
}

interface VideoRoom {
  id: string;
  title: string;
  room_code: string;
  is_public: boolean;
  scheduled_start: string | null;
  started_at: string | null;
  ended_at: string | null;
  created_at: string;
  is_active: boolean;
  created_by: string;
}

export default function VideoPage() {
  const session = useSession();
  const [socket, setSocket] = useState<Socket | null>(null);
  const [view, setView] = useState<"create" | "history" | "call">("create");
  const [roomId, setRoomId] = useState<string | null>(null);
  const [currentRoomCode, setCurrentRoomCode] = useState<string | null>(null);
  const [micOn, setMicOn] = useState(true);
  const [cameraOn, setCameraOn] = useState(true);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const [showCreateModal, setShowCreateModal] = useState(false);
  const [showJoinModal, setShowJoinModal] = useState(false);
  const [copiedCode, setCopiedCode] = useState<string | null>(null);
  
  const [participants, setParticipants] = useState<Participant[]>([]);
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [messageInput, setMessageInput] = useState("");

  const [activeRooms, setActiveRooms] = useState<VideoRoom[]>([]);
  const [pastRooms, setPastRooms] = useState<VideoRoom[]>([]);

  const [newRoom, setNewRoom] = useState({
    title: "",
    description: "",
    is_public: true,
    scheduled_start: "",
  });
  const [joinCode, setJoinCode] = useState("");

  const localVideoRef = useRef<HTMLVideoElement | null>(null);
  const remoteVideoRef = useRef<HTMLVideoElement | null>(null);
  const peerRef = useRef<RTCPeerConnection | null>(null);
  const localStreamRef = useRef<MediaStream | null>(null);
  const chatEndRef = useRef<HTMLDivElement>(null);

  const [sessionReady, setSessionReady] = useState(false);

  // Check session ready
  useEffect(() => {
    const check = async () => {
      const { data } = await supabase.auth.getSession();
      if (data?.session) {
        setSessionReady(true);
      } else {
        const { data: sub } = supabase.auth.onAuthStateChange((_event, s) => {
          if (s?.user) setSessionReady(true);
        });
        return () => sub.subscription.unsubscribe();
      }
    };
    check();
  }, []);

  // Socket connection
  useEffect(() => {
    if (!sessionReady || !session) return;

    const s = io(SERVER_URL, {
      auth: { token: (session as any).access_token },
    });

    s.on("connect", () => console.log("🔗 Socket connected:", s.id));
    s.on("disconnect", () => console.log("❌ Socket disconnected"));
    setSocket(s);

    return () => {
      s.removeAllListeners();
      s.disconnect();
    };
  }, [sessionReady, session]);

  // Fetch active and past rooms
  useEffect(() => {
    if (!sessionReady || view !== "create") return;

    const fetchRooms = async () => {
      try {
        // Fetch active rooms (not ended, within 1 hour)
        const { data: active, error: activeError } = await supabase
          .from("video_rooms")
          .select("*")
          .eq("is_active", true)
          .order("created_at", { ascending: false });

        if (activeError) throw activeError;

        const validActive = (active || []).filter((room) => {
          if (!room.started_at) return true;
          const ageMinutes = (Date.now() - new Date(room.started_at).getTime()) / 60000;
          return ageMinutes <= 60;
        });

        setActiveRooms(validActive);
      } catch (err) {
        console.error("Error fetching active rooms:", err);
      }
    };

    fetchRooms();
    const interval = setInterval(fetchRooms, 30000); // Refresh every 30s
    return () => clearInterval(interval);
  }, [sessionReady, view]);

  // Fetch history
  useEffect(() => {
    if (!sessionReady || view !== "history") return;

    const fetchHistory = async () => {
      try {
        const { data, error } = await supabase
          .from("video_rooms")
          .select("*")
          .eq("is_active", false)
          .order("ended_at", { ascending: false })
          .limit(50);

        if (error) throw error;
        setPastRooms(data || []);
      } catch (err) {
        console.error("Error fetching history:", err);
      }
    };

    fetchHistory();
  }, [sessionReady, view]);

  // Auto-scroll chat
  useEffect(() => {
    chatEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  // Attach local stream to video
  useEffect(() => {
    if (localStreamRef.current && localVideoRef.current && view === "call") {
      localVideoRef.current.srcObject = localStreamRef.current;
      localVideoRef.current.play().catch((err) => console.error("Play error:", err));
    }
  }, [localStreamRef.current, view, cameraOn]);

  // Socket listeners for participants and chat
  useEffect(() => {
    if (!socket || !roomId) return;

    const handleParticipantsUpdate = (data: { participants: Participant[] }) => {
      console.log("👥 Participants update:", data.participants);
      setParticipants(data.participants);
    };

    const handleChatMessage = (data: ChatMessage) => {
      console.log("💬 Chat message received:", data);
      setMessages((prev) => {
        // Avoid duplicates
        if (prev.some(m => m.id === data.id)) return prev;
        return [...prev, data];
      });
    };

    socket.on("video:participants-update", handleParticipantsUpdate);
    socket.on("video:chat-message", handleChatMessage);

    return () => {
      socket.off("video:participants-update", handleParticipantsUpdate);
      socket.off("video:chat-message", handleChatMessage);
    };
  }, [socket, roomId]);

  // const startLocalStream = async () => {
  //   try {
  //     const stream = await navigator.mediaDevices.getUserMedia({
  //       video: { width: { ideal: 1280 }, height: { ideal: 720 } },
  //       audio: true
  //     });
  //     localStreamRef.current = stream;
  //     return stream;
  //   } catch (err: any) {
  //     setError(`Camera/Mic access denied: ${err.message}`);
  //     throw err;
  //   }
  // };

  // for testing purposes, allow audio only if video fails

  const [testMode, setTestMode] = useState(false); // Add this state

// Replace your startLocalStream function with this:
const startLocalStream = async () => {
  try {
    let stream: MediaStream;

    if (testMode) {
      // 🎭 TEST MODE: Create fake media stream
      console.log("🎭 Using TEST MODE - fake media stream");
      
      // Create canvas for fake video
      const canvas = document.createElement('canvas');
      canvas.width = 640;
      canvas.height = 480;
      const ctx = canvas.getContext('2d')!;
      
      // Draw animated fake video
      const drawFrame = () => {
        const time = Date.now() / 1000;
        
        // Gradient background
        const gradient = ctx.createLinearGradient(0, 0, 640, 480);
        gradient.addColorStop(0, `hsl(${(time * 50) % 360}, 70%, 50%)`);
        gradient.addColorStop(1, `hsl(${(time * 50 + 180) % 360}, 70%, 30%)`);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 640, 480);
        
        // Draw text
        ctx.fillStyle = 'white';
        ctx.font = 'bold 40px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('TEST MODE', 320, 200);
        ctx.font = '20px Arial';
        ctx.fillText(session?.user?.email || 'Test User', 320, 250);
        ctx.fillText(new Date().toLocaleTimeString(), 320, 290);
        
        // Draw moving circle
        const x = 320 + Math.cos(time * 2) * 200;
        const y = 240 + Math.sin(time * 2) * 100;
        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.beginPath();
        ctx.arc(x, y, 30, 0, Math.PI * 2);
        ctx.fill();
      };
      
      // Animate at 30fps
      const interval = setInterval(drawFrame, 1000 / 30);
      
      // Get video stream from canvas
      const videoStream = canvas.captureStream(30);
      
      // Create fake audio (silent)
      const audioContext = new AudioContext();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      gainNode.gain.value = 0.01; // Very quiet
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      oscillator.start();
      
      const audioDestination = audioContext.createMediaStreamDestination();
      gainNode.connect(audioDestination);
      
      // Combine video and audio
      stream = new MediaStream([
        ...videoStream.getVideoTracks(),
        ...audioDestination.stream.getAudioTracks()
      ]);
      
      // Store interval for cleanup
      (stream as any)._testModeInterval = interval;
      (stream as any)._audioContext = audioContext;
      
    } else {
      // 📹 REAL MODE: Use actual camera/mic
      console.log("📹 Using REAL camera and microphone");
      stream = await navigator.mediaDevices.getUserMedia({
        video: { width: { ideal: 1280 }, height: { ideal: 720 } },
        audio: true
      });
    }

    localStreamRef.current = stream;
    return stream;
  } catch (err: any) {
    setError(`Camera/Mic access denied: ${err.message}`);
    throw err;
  }
};

// testing line eds above 

  const initPeer = (signalingRoomId: string) => {
    if (peerRef.current) {
      peerRef.current.close();
    }

    const peer = new RTCPeerConnection({
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "stun:stun1.l.google.com:19302" },
      ],
    });

    peer.onicecandidate = (e) => {
      if (e.candidate && socket) {
        socket.emit("webrtc:ice-candidate", {
          roomId: signalingRoomId,
          candidate: e.candidate,
        });
      }
    };

    peer.ontrack = (e) => {
      if (e.streams[0] && remoteVideoRef.current) {
        remoteVideoRef.current.srcObject = e.streams[0];
        remoteVideoRef.current.play().catch(err => console.error("Remote play error:", err));
      }
    };

    peerRef.current = peer;
    return peer;
  };

  const createRoomInSupabase = async () => {
    if (!session?.user?.id) return null;

    const payload = {
      title: newRoom.title?.trim() || "Untitled Meeting",
      description: newRoom.description?.trim() || "",
      is_public: newRoom.is_public ?? true,
      scheduled_start: newRoom.scheduled_start || null,
      created_by: session.user.id,
      started_at: new Date().toISOString(),
      is_active: true,
    };

    try {
      const { data, error } = await supabase
        .from("video_rooms")
        .insert([payload])
        .select()
        .single();

      if (error) throw error;

      // Add creator as host participant
      await supabase.from("video_participants").insert([{
        room_id: data.id,
        user_id: session.user.id,
        role: "host",
        joined_at: new Date().toISOString()
      }]);

      return data;
    } catch (err) {
      console.error("Create room error:", err);
      setError("Failed to create room");
      return null;
    }
  };

  const joinRoom = async (roomCodeOrId: string, useRoomId = false) => {
    if (!socket || !session) {
      setError("Not connected");
      return;
    }

    setLoading(true);
    setError(null);

    try {
      // Get room from database
      const query = useRoomId
        ? supabase.from("video_rooms").select("*").eq("id", roomCodeOrId).single()
        : supabase.from("video_rooms").select("*").eq("room_code", roomCodeOrId).single();

      const { data: room, error: roomError } = await query;

      if (roomError || !room) throw new Error("Room not found");
      if (!room.is_active) throw new Error("This room has ended");

      // Check expiry
      if (room.started_at) {
        const ageMinutes = (Date.now() - new Date(room.started_at).getTime()) / 60000;
        if (ageMinutes > 60) throw new Error("Meeting expired (over 1 hour)");
      }

      // Start media stream
      const stream = await startLocalStream();
      const peer = initPeer(room.id);

      stream.getTracks().forEach((track) => {
        peer.addTrack(track, stream);
      });

      // Add user as participant
      await supabase.from("video_participants").upsert([{
        room_id: room.id,
        user_id: session.user.id,
        role: "guest",
        joined_at: new Date().toISOString()
      }], { onConflict: "room_id,user_id" });

      // Fetch existing participants
      const { data: participantsData } = await supabase
        .from("video_participants")
        .select(`
          user_id,
          role,
          profiles:user_id(full_name)
        `)
        .eq("room_id", room.id)
        .is("left_at", null);

      if (participantsData) {
        setParticipants(
          participantsData.map((p: any) => ({
            id: p.user_id,
            user_id: p.user_id,
            user_name: p.profiles?.full_name || "Guest",
            role: p.role,
            isSelf: p.user_id === session.user.id
          }))
        );
      }

      // Fetch chat history
      const { data: chatData } = await supabase
        .from("video_messages")
        .select(`
          id,
          user_id,
          message,
          created_at,
          profiles:user_id(full_name)
        `)
        .eq("room_id", room.id)
        .order("created_at", { ascending: true });

      if (chatData) {
        setMessages(
          chatData.map((m: any) => ({
            id: m.id,
            user_id: m.user_id,
            user_name: m.profiles?.full_name || "Unknown",
            message: m.message,
            created_at: m.created_at
          }))
        );
      }

      // Join socket room
      socket.emit("video:join-room", {
        roomId: room.id,
        userId: session.user.id,
        userName: session.user.user_metadata?.full_name || "Guest"
      });

      // Setup WebRTC signaling
      socket.emit("webrtc:join", { roomId: room.id });

      socket.on("webrtc:user-joined", async ({ id: userSocketId }) => {
        const offer = await peer.createOffer();
        await peer.setLocalDescription(offer);
        socket.emit("webrtc:offer", { roomId: room.id, offer });
      });

      socket.on("webrtc:offer", async ({ offer }) => {
        await peer.setRemoteDescription(new RTCSessionDescription(offer));
        const answer = await peer.createAnswer();
        await peer.setLocalDescription(answer);
        socket.emit("webrtc:answer", { roomId: room.id, answer });
      });

      socket.on("webrtc:answer", async ({ answer }) => {
        await peer.setRemoteDescription(new RTCSessionDescription(answer));
      });

      socket.on("webrtc:ice-candidate", async ({ candidate }) => {
        await peer.addIceCandidate(new RTCIceCandidate(candidate));
      });

      socket.on("webrtc:user-left", () => {
        if (remoteVideoRef.current) remoteVideoRef.current.srcObject = null;
      });

      setRoomId(room.id);
      setCurrentRoomCode(room.room_code);
      setView("call");
    } catch (err: any) {
      console.error("Join room error:", err);
      setError(err?.message || "Failed to join room");
    } finally {
      setLoading(false);
    }
  };

  const sendMessage = async () => {
    const text = messageInput.trim();
    if (!text || !roomId || !session?.user || !socket) return;

    const newMessage: ChatMessage = {
      user_id: session.user.id,
      user_name: session.user.user_metadata?.full_name || "You",
      message: text,
      created_at: new Date().toISOString()
    };

    // Save to database
    const { data, error } = await supabase
      .from("video_messages")
      .insert([{
        room_id: roomId,
        user_id: session.user.id,
        message: text
      }])
      .select()
      .single();

    if (!error && data) {
      newMessage.id = data.id;
    }

    // Broadcast via socket
    socket.emit("video:chat-message", {
      roomId,
      ...newMessage
    });

    // Add to local state
    setMessages(prev => [...prev, newMessage]);
    setMessageInput("");
  };

  const handleConfirmCreate = async () => {
    setShowCreateModal(false);
    setLoading(true);
    const room = await createRoomInSupabase();
    if (room) {
      await joinRoom(room.id, true);
    }
    setLoading(false);
  };

  const handleConfirmJoin = async () => {
    if (!joinCode.trim()) return;
    setShowJoinModal(false);
    await joinRoom(joinCode.trim(), false);
  };

  // const handleEndCall = async () => {
  //   if (roomId && session?.user) {
  //     await supabase
  //       .from("video_participants")
  //       .update({ left_at: new Date().toISOString() })
  //       .eq("room_id", roomId)
  //       .eq("user_id", session.user.id);
  //   }

  //   if (peerRef.current) {
  //     peerRef.current.close();
  //     peerRef.current = null;
  //   }
  //   if (localStreamRef.current) {
  //     localStreamRef.current.getTracks().forEach(t => t.stop());
  //     localStreamRef.current = null;
  //   }
  //   if (socket && roomId) {
  //     socket.emit("webrtc:leave", { roomId });
  //     socket.emit("video:leave-room", { roomId });
  //   }
  //   if (localVideoRef.current) localVideoRef.current.srcObject = null;
  //   if (remoteVideoRef.current) remoteVideoRef.current.srcObject = null;

  //   setRoomId(null);
  //   setCurrentRoomCode(null);
  //   setParticipants([]);
  //   setMessages([]);
  //   setView("create");
  // };


  // for testing purpose of endcall replace above with:

  
// Update handleEndCall to cleanup test mode:
const handleEndCall = async () => {
  if (roomId && session?.user) {
    await supabase
      .from("video_participants")
      .update({ left_at: new Date().toISOString() })
      .eq("room_id", roomId)
      .eq("user_id", session.user.id);
  }

  if (peerRef.current) {
    peerRef.current.close();
    peerRef.current = null;
  }
  
  if (localStreamRef.current) {
    localStreamRef.current.getTracks().forEach(t => t.stop());
    
    // Cleanup test mode resources
    if ((localStreamRef.current as any)._testModeInterval) {
      clearInterval((localStreamRef.current as any)._testModeInterval);
    }
    if ((localStreamRef.current as any)._audioContext) {
      (localStreamRef.current as any)._audioContext.close();
    }
    
    localStreamRef.current = null;
  }
  
  if (socket && roomId) {
    socket.emit("webrtc:leave", { roomId });
    socket.emit("video:leave-room", { roomId });
  }
  
  if (localVideoRef.current) localVideoRef.current.srcObject = null;
  if (remoteVideoRef.current) remoteVideoRef.current.srcObject = null;

  setRoomId(null);
  setCurrentRoomCode(null);
  setParticipants([]);
  setMessages([]);
  setView("create");
};

// testing endcall ends above 

  const toggleMic = () => {
    if (!localStreamRef.current) return;
    const newState = !micOn;
    localStreamRef.current.getAudioTracks().forEach(t => t.enabled = newState);
    setMicOn(newState);
  };

  const toggleCamera = () => {
    if (!localStreamRef.current) return;
    const newState = !cameraOn;
    localStreamRef.current.getVideoTracks().forEach(t => t.enabled = newState);
    setCameraOn(newState);
  };

  const copyRoomCode = (code: string) => {
    navigator.clipboard.writeText(code);
    setCopiedCode(code);
    setTimeout(() => setCopiedCode(null), 2000);
  };

  if (!sessionReady) {
    return (
      <Container className="vh-100 d-flex justify-content-center align-items-center">
        <Spinner animation="border" />
        <div className="ms-3">Loading...</div>
      </Container>
    );
  }

  if (loading) {
    return (
      <Container className="vh-100 d-flex flex-column justify-content-center align-items-center">
        <Spinner animation="border" />
        <p className="mt-3">Setting up video...</p>
      </Container>
    );
  }

  return (
    <div style={{ marginLeft: "0", padding: "0", minHeight: "100vh", background: "#f9fafc" }}>
      <Container fluid className="py-3">
        {error && <Alert variant="danger" dismissible onClose={() => setError(null)}>{error}</Alert>}

        <Nav
          variant="tabs"
          activeKey={view}
          onSelect={(v) => setView(v as any)}
          className="mb-3 justify-content-center"
        >
          <Nav.Item>
            <Nav.Link eventKey="create">Create / Join</Nav.Link>
          </Nav.Item>
          <Nav.Item>
            <Nav.Link eventKey="history">History</Nav.Link>
          </Nav.Item>
        </Nav>

        
{/* // Add this toggle button in your create/join view (before the Create/Join buttons): */}
{view === "create" && (
  <div className="mt-4">
    <div className="d-flex justify-content-center mb-3">
      <Form.Check
        type="switch"
        id="test-mode-switch"
        label={
          <span>
            🎭 Test Mode (Use fake camera/mic - for testing multiple tabs)
          </span>
        }
        checked={testMode}
        onChange={(e) => setTestMode(e.target.checked)}
      />
    </div>
    
    {testMode && (
      <Alert variant="info" className="mx-auto" style={{ maxWidth: "600px" }}>
        <Alert.Heading>🎭 Test Mode Enabled</Alert.Heading>
        <p className="mb-0 small">
          Using fake animated video and silent audio. You can now open multiple tabs/windows
          to test multi-user calls without "device in use" errors!
        </p>
      </Alert>
    )}
    
    <h4 className="text-center">Video Meetings</h4>
    {/* ... rest of your create view */}
  </div>
)}

        {view === "create" && (
          <div className="mt-4">
            <h4 className="text-center">Video Meetings</h4>
            
            <div className="d-flex justify-content-center gap-3 my-4">
              <Button variant="secondary" onClick={() => setShowJoinModal(true)}>
                Join Room
              </Button>
              <Button variant="primary" onClick={() => setShowCreateModal(true)}>
                Create Room
              </Button>
            </div>

            <Row className="justify-content-center">
              <Col lg={10}>
                <Card className="shadow-sm">
                  <Card.Header>
                    <h5 className="mb-0">Active Meetings</h5>
                  </Card.Header>
                  <Card.Body>
                    {activeRooms.length === 0 ? (
                      <p className="text-muted text-center">No active meetings</p>
                    ) : (
                      <Table responsive hover>
                        <thead>
                          <tr>
                            <th>Title</th>
                            <th>Room Code</th>
                            <th>Status</th>
                            <th>Started</th>
                            <th>Actions</th>
                          </tr>
                        </thead>
                        <tbody>
                          {activeRooms.map((room) => (
                            <tr key={room.id}>
                              <td><strong>{room.title}</strong></td>
                              <td>
                                <code>{room.room_code}</code>
                                <Button
                                  size="sm"
                                  variant="link"
                                  onClick={() => copyRoomCode(room.room_code)}
                                  className="ms-2"
                                >
                                  {copiedCode === room.room_code ? (
                                    <FaCheck color="green" />
                                  ) : (
                                    <FaCopy />
                                  )}
                                </Button>
                              </td>
                              <td>
                                <Badge bg="success">Active</Badge>
                              </td>
                              <td>
                                {room.started_at
                                  ? new Date(room.started_at).toLocaleString()
                                  : "Not started"}
                              </td>
                              <td>
                                <Button
                                  size="sm"
                                  variant="primary"
                                  onClick={() => joinRoom(room.room_code, false)}
                                >
                                  Join
                                </Button>
                              </td>
                            </tr>
                          ))}
                        </tbody>
                      </Table>
                    )}
                  </Card.Body>
                </Card>
              </Col>
            </Row>
          </div>
        )}

        {view === "history" && (
          <Row className="justify-content-center">
            <Col lg={10}>
              <Card className="shadow-sm">
                <Card.Header>
                  <h5 className="mb-0">Call History</h5>
                </Card.Header>
                <Card.Body>
                  {pastRooms.length === 0 ? (
                    <p className="text-muted text-center">No past meetings</p>
                  ) : (
                    <Table responsive hover>
                      <thead>
                        <tr>
                          <th>Title</th>
                          <th>Room Code</th>
                          <th>Started</th>
                          <th>Ended</th>
                          <th>Duration</th>
                        </tr>
                      </thead>
                      <tbody>
                        {pastRooms.map((room) => {
                          const duration = room.started_at && room.ended_at
                            ? Math.round(
                                (new Date(room.ended_at).getTime() -
                                  new Date(room.started_at).getTime()) /
                                  60000
                              )
                            : null;

                          return (
                            <tr key={room.id}>
                              <td>{room.title}</td>
                              <td><code>{room.room_code}</code></td>
                              <td>
                                {room.started_at
                                  ? new Date(room.started_at).toLocaleString()
                                  : "-"}
                              </td>
                              <td>
                                {room.ended_at
                                  ? new Date(room.ended_at).toLocaleString()
                                  : "-"}
                              </td>
                              <td>{duration ? `${duration} min` : "-"}</td>
                            </tr>
                          );
                        })}
                      </tbody>
                    </Table>
                  )}
                </Card.Body>
              </Card>
            </Col>
          </Row>
        )}

        {view === "call" && (
          <Row className="justify-content-center g-3">
            <Col lg={8}>
              <Card className="shadow-lg border-0 rounded-4">
                <Card.Body className="p-0">
                  <div className="position-relative bg-dark" style={{ height: "500px" }}>
                    <video
                      ref={remoteVideoRef}
                      autoPlay
                      playsInline
                      className="w-100 h-100"
                      style={{ objectFit: "cover", background: "#111" }}
                    />

                    <div
                      className="position-absolute bottom-0 end-0 p-2"
                      style={{
                        width: "180px",
                        height: "130px",
                        borderRadius: "10px",
                        overflow: "hidden",
                        border: "2px solid #fff",
                        background: "#000",
                      }}
                    >
                      <video
                        ref={localVideoRef}
                        autoPlay
                        playsInline
                        muted
                        className="w-100 h-100"
                        style={{
                          objectFit: "cover",
                          display: cameraOn ? "block" : "none",
                        }}
                      />

                      {!cameraOn && (
                        <div className="w-100 h-100 d-flex justify-content-center align-items-center bg-secondary text-white">
                          <div
                            style={{
                              width: "50px",
                              height: "50px",
                              borderRadius: "50%",
                              background: "#444",
                              display: "flex",
                              alignItems: "center",
                              justifyContent: "center",
                            }}
                          >
                            {session?.user?.user_metadata?.full_name?.[0]?.toUpperCase() || "U"}
                          </div>
                        </div>
                      )}
                    </div>

                    {currentRoomCode && (
                      <div className="position-absolute top-0 start-0 m-3">
                        <Badge bg="dark" className="fs-6">
                          Room: {currentRoomCode}
                        </Badge>
                      </div>
                    )}
                  </div>

                  <div className="d-flex justify-content-center align-items-center gap-4 py-3 bg-white">
                    <Button
                      onClick={toggleMic}
                      variant={micOn ? "light" : "danger"}
                      className="rounded-circle shadow-sm p-3"
                    >
                      {micOn ? <FaMicrophone size={18} /> : <FaMicrophoneSlash size={18} />}
                    </Button>

                    <Button
                      onClick={toggleCamera}
                      variant={cameraOn ? "light" : "danger"}
                      className="rounded-circle shadow-sm p-3"
                    >
                      {cameraOn ? <FaVideo size={18} /> : <FaVideoSlash size={18} />}
                    </Button>

                    <Button
                      variant="danger"
                      onClick={handleEndCall}
                      className="rounded-circle shadow p-3"
                    >
                      <FaPhoneSlash size={18} color="#fff" />
                    </Button>
                  </div>
                </Card.Body>
              </Card>
            </Col>

            <Col lg={4}>
              <Card className="shadow-sm border-0 rounded-4 h-100">
                <Card.Body className="p-3">
                  <Tab.Container defaultActiveKey="participants">
                    <Nav variant="pills" className="mb-3 justify-content-around">
                      <Nav.Item>
                        <Nav.Link eventKey="participants">Participants ({participants.length})</Nav.Link>
                      </Nav.Item>
                      <Nav.Item>
                        <Nav.Link eventKey="chat">Chat</Nav.Link>
                      </Nav.Item>
                    </Nav>

                    <Tab.Content>
                      <Tab.Pane eventKey="participants">
                        <div style={{ maxHeight: "60vh", overflowY: "auto" }}>
                          {participants.length === 0 ? (
                            <p className="text-muted small">No participants yet</p>
                          ) : (
                            <ul className="list-unstyled">
                              {participants.map((p) => (
                                <li key={p.id} className="mb-2 d-flex align-items-center">
                                  <div
                                    style={{
                                      width: "30px",
                                      height: "30px",
                                      borderRadius: "50%",
                                      background: "#007bff",
                                      color: "#fff",
                                      display: "flex",
                                      alignItems: "center",
                                      justifyContent: "center",
                                      marginRight: "10px",
                                    }}
                                  >
                                    {p.user_name[0]?.toUpperCase()}
                                  </div>
                                  <div>
                                    {p.user_name} {p.isSelf && "(You)"}
                                    {p.role === "host" && <Badge bg="primary" className="ms-2">Host</Badge>}
                                  </div>
                                </li>
                              ))}
                            </ul>
                          )}
                        </div>
                      </Tab.Pane>

                      <Tab.Pane eventKey="chat">
                        <div
                          className="bg-light rounded-3 p-3 mb-3"
                          style={{ height: "50vh", overflowY: "auto" }}
                        >
                          {messages.length === 0 ? (
                            <p className="text-muted small">No messages yet</p>
                          ) : (
                            messages.map((m, idx) => (
                              <div key={m.id || idx} className="mb-3">
                                <div className="small text-muted">
                                  <strong>{m.user_name}</strong> •{" "}
                                  {new Date(m.created_at).toLocaleTimeString()}
                                </div>
                                <div>{m.message}</div>
                              </div>
                            ))
                          )}
                          <div ref={chatEndRef} />
                        </div>

                        <div className="d-flex gap-2">
                          <Form.Control
                            placeholder="Type a message..."
                            value={messageInput}
                            onChange={(e) => setMessageInput(e.target.value)}
                            onKeyPress={(e) => {
                              if (e.key === "Enter" && !e.shiftKey) {
                                e.preventDefault();
                                sendMessage();
                              }
                            }}
                            className="rounded-pill"
                          />
                          <Button
                            variant="primary"
                            className="rounded-pill px-3"
                            onClick={sendMessage}
                            disabled={!messageInput.trim()}
                          >
                            Send
                          </Button>
                        </div>
                      </Tab.Pane>
                    </Tab.Content>
                  </Tab.Container>
                </Card.Body>
              </Card>
            </Col>
          </Row>
        )}
      </Container>

      {/* Create Room Modal */}
      <Modal show={showCreateModal} onHide={() => setShowCreateModal(false)}>
        <Modal.Header closeButton>
          <Modal.Title>Create a Meeting Room</Modal.Title>
        </Modal.Header>
        <Modal.Body>
          <Form>
            <Form.Group className="mb-3">
              <Form.Label>Meeting Title *</Form.Label>
              <Form.Control
                placeholder="Team Standup"
                value={newRoom.title}
                onChange={(e) => setNewRoom({ ...newRoom, title: e.target.value })}
              />
            </Form.Group>

            <Form.Group className="mb-3">
              <Form.Label>Description</Form.Label>
              <Form.Control
                as="textarea"
                rows={3}
                value={newRoom.description}
                onChange={(e) => setNewRoom({ ...newRoom, description: e.target.value })}
                placeholder="Optional meeting description"
              />
            </Form.Group>

            <Form.Group className="mb-3">
              <Form.Check
                type="switch"
                label="Public room (anyone with code can join)"
                checked={newRoom.is_public}
                onChange={(e) => setNewRoom({ ...newRoom, is_public: e.target.checked })}
              />
            </Form.Group>

            <Form.Group className="mb-3">
              <Form.Label>Schedule Start Time (optional)</Form.Label>
              <Form.Control
                type="datetime-local"
                value={newRoom.scheduled_start}
                onChange={(e) => setNewRoom({ ...newRoom, scheduled_start: e.target.value })}
              />
              <Form.Text className="text-muted">
                Leave empty to start immediately
              </Form.Text>
            </Form.Group>
          </Form>
        </Modal.Body>
        <Modal.Footer>
          <Button variant="secondary" onClick={() => setShowCreateModal(false)}>
            Cancel
          </Button>
          <Button 
            variant="primary" 
            onClick={handleConfirmCreate}
            disabled={!newRoom.title.trim()}
          >
            Create & Join
          </Button>
        </Modal.Footer>
      </Modal>

      {/* Join Room Modal */}
      <Modal show={showJoinModal} onHide={() => setShowJoinModal(false)}>
        <Modal.Header closeButton>
          <Modal.Title>Join a Meeting</Modal.Title>
        </Modal.Header>
        <Modal.Body>
          <Form>
            <Form.Group>
              <Form.Label>Room Code *</Form.Label>
              <Form.Control
                placeholder="Enter 8-character code"
                value={joinCode}
                onChange={(e) => setJoinCode(e.target.value.toUpperCase())}
                maxLength={8}
              />
              <Form.Text className="text-muted">
                Ask the meeting host for the room code
              </Form.Text>
            </Form.Group>
          </Form>
        </Modal.Body>
        <Modal.Footer>
          <Button variant="secondary" onClick={() => setShowJoinModal(false)}>
            Cancel
          </Button>
          <Button 
            variant="primary" 
            onClick={handleConfirmJoin}
            disabled={!joinCode.trim()}
          >
            Join Meeting
          </Button>
        </Modal.Footer>
      </Modal>
    </div>
  );
}